---
title: Buenas practicas de seguridad para Smart Contracts en Ethereum. Recomendaciones de desarrollo II.
description: En este articulo exploraremos las vulnerabilidades relacionadas con el env칤o forzado de Ether, hablaremos acerca de la publicidad de la informaci칩n en blockchain, sobre porque no debemos asumir una posici칩n de confianza en ning칰n escenario y sobre algunos problemas relacionados con los n칰meros enteros con signo.
publishedAt: 2023/03/22
tags:
  - Solidity
  - Ethereum
  - EVM
  - Smart Contract
  - Seguridad
  - Buenas pr치cticas
---

## Envio forzado de Ether

**En Ethereum, existen formas de forzar el env칤o de Ether a una direcci칩n cualquiera, sin autorizaci칩n y sin posibilidades de evitarlo.** Ten cuidado de depender estrictamente del balance global de tu contrato para controlar aspectos relacionados con la logica de tu negocio, un agente malisioso puede enviar forzozamente Ether a tu contrato y no lo podr치s evitar nisquiera con un `revert()` en tu `fallback()` o en tu `receive()`.

El atacante puede hacer esto creando un contrato, financi치ndolo con 1 wei e invocando `selfdestruct (victimAddress)`. Cuando esto ocurra no se invocar치 ning칰n c칩digo en `victimAddress`, por lo que no se podr치 prevenir.

Adem치s, dado que las direcciones de los contrato se pueden predecir, es posible enviar ether a una direcci칩n antes de que el contrato sea desplegado como lo explicamos en el articulo anterior ([issue 61](https://github.com/ConsenSys/smart-contract-best-practices/issues/61)).

Ve치se [SWC-132](https://swcregistry.io/docs/SWC-132) (_Unexpected Ether balance_).

Sin embargo, ante este escenario tan desalentador, quiz치, existe una forma de resolver este problema. Si la l칩gica de tu negocio o de tu sistema depende del balance de tu contrato no confies en la variable global `balance` que te provee la EVM sobre el estado de contrato. Lo mejor es crear una varible de estado que lleve la cuenta de los envi칩s de Ether a trav칠z de una funci칩n creada por ti . Veamos un ejemplo:

```tsx
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Bank {
	uint256 public balance;

	function addFunds() public payable returns (bool) {
		balance += msg.value;
	}

}
```

De esta forma tu tienes el control total sobre el balance que usar치s para administrar tu sistema.

# Manteniendo la informaci칩n oculta

Muchas aplicaciones requieren que los datos enviados sean privados hasta cierto punto para que funcionen. Los juegos (por ejemplo, piedra-papel-tijera) y los mecanismos de subasta (por ejemplo, subastas de Vickrey con oferta sellada (las subastas de tipo Vickrey son aquellas en las que los postores hacen ofertas sin conocer las ofertas de los dem치s)) son dos ejemplos paradigm치ticos. Si est치s construyendo una aplicaci칩n donde la privacidad es importante, aseg칰rate de evitar exigir a los usuarios que publiquen informaci칩n demasiado pronto. La mejor estrategia es utilizar esquemas de compromiso (_[commitment schemes](https://en.wikipedia.org/wiki/Commitment_scheme)_) con fases separadas: primero comprometerse utilizando el hash de los valores que se env칤en y, en una fase posterior, revelar los valores.

Sin embargo, debes tener cuidado para asegurarte de que el valor almacenado como hash no sea reconocible (y por lo tanto, no se pueda desenmascarar), ya que esto anular칤a el segundo prop칩sito del hashing: evitar la revelaci칩n de dichos valores. Por ejemplo:

Supongamos que un contrato inteligente permite a 2 jugadores jugar _piedra, papel o tijera_, y utiliza este esquema de compromiso-revelaci칩n: ambos jugadores deben enviar un hash de su movimiento antes de que cualquiera de ellos env칤e la 칰ltima transacci칩n (que termina el juego). El resultado de la funci칩n `keccak256(piedra)` es `5efc69eb65398dda10fb098235896a16d2928e01092da80cc2a9c4b92c2caeea`. Si estuvieras jugando y vieras que tu oponente se est치 comprometiendo con esto y sabes que las tres opciones posibles son piedra, papel o tijera, 쯡o te dir칤a esto exactamente qu칠 movimiento ha elegido tu oponente luego de tres pruebas? Una implementaci칩n m치s segura ser칤a hacer hash no solo del nombre del movimiento, sino tambi칠n, por ejemplo, un n칰mero cualquiera proporcionado por el usuario elegido por el usuario. Eso har칤a que el hash resultante no sea f치cilmente reconocible, incrementando la cantidad de pruebas necesarias a una decena de billones (con suerte) antes de encontrar el valor suscrito.

Ejemplos:

- En piedra, papel o tijera, haz que ambos jugadores env칤en un hash de su movimiento previsto primero, luego puedes hacer que ambos jugadores env칤en su movimiento; si el movimiento enviado no coincide con el hash, no lo aceptes.
- En una subasta, requerir que los jugadores env칤en un hash con el valor de su oferta en una fase inicial (junto con un dep칩sito mayor que su valor de oferta) y luego env칤en su valor de oferta de subasta en la segunda fase. N칩tese que esta t칠cnica requiere que los usuarios tengan un balance superior para poder participar. Lo puedes ajustar para que sea un valor aleatorio, pero podr칤an surgir otros problemas.
- Al desarrollar una aplicaci칩n que depende de la generaci칩n de n칰meros aleatorios, el orden siempre deber칤a ser (1) los jugadores env칤an movimientos, (2) se genera un n칰mero aleatorio, (3) se paga a los ganadores.

El m칠todo por el cual se generan los n칰meros aleatorios Ethereum es en s칤 mismo un 치rea activa de investigaci칩n; las mejores soluciones actualmente son los encabezados de bloque de Bitcoin (verificados a trav칠s de [http://btcrelay.org](http://btcrelay.org/)), esquemas de compromiso de hash-revelaci칩n (es decir, una parte genera un n칰mero, publica su hash para "comprometerse" con el valor y luego revela el valor m치s tarde), [RANDAO](https://github.com/randao/randao) (m치s sobre RANDAO pronto 游) y la m치s interesante para m칤, las [_Verifiable Random Functions_ creadas por el equipo de Chainlink](https://docs.chain.link/vrf/v2/introduction/). **Como Ethereum es un protocolo determinista, ninguna variable dentro del protocolo podr칤a usarse como n칰mero aleatorio impredecible.** Incluso, los mineros tienen cierto control sobre el valor de la variable global "block.blockhash()".

## 쯈u칠 sucede cuando alguien act칰a de mala fe?

No hagas que los procesos de reembolso o reclamaci칩n dependan de que una parte realice una acci칩n particular sin proveer otra forma de obtener los fondos. Por ejemplo, en un juego de piedra, papel y tijeras, un error com칰n es no hacer un pago hasta que ambos jugadores env칤en sus movimientos; puede pasar que un jugador malintencionado pueda querer "da침ar" al otro simplemente no enviando su movimiento. De hecho, si un jugador ve el movimiento revelado del otro jugador y determina que perdi칩, no tiene ninguna raz칩n para enviar su propio movimiento en absoluto. Cuando estas situaciones son un problema, (1) crea una forma de evitar que los usuarios no participen, quiz치s a trav칠s de un l칤mite de tiempo, y (2) otra opci칩n es repartir incentivos para que los participantes env칤en informaci칩n en todas las situaciones en las que se supone que deben hacerlo.

## Negaci칩n de enteros con signo

Solidity proporciona varios tipos para trabajar con enteros con signo. Al igual que en la mayor칤a de los lenguajes de programaci칩n, en Solidity un entero con signo de`N`막its puede representar valores desde`-2^(N-1)`맏asta`2^(N-1)-1`. Esto significa que no hay un equivalente positivo para`MIN_INT`. La negaci칩n se implementa encontrando el complemento a dos de un n칰mero, por lo que la negaci칩n del menor n칰mero negativo [resultar치 en el mismo n칰mero](https://en.wikipedia.org/wiki/Two%27s_complement#Most_negative_number) (sobre este problema volveremos m치s adelante).

Esto es cierto para todos los tipos de enteros con signo en Solidity (`int8`,`int16`, ...,`int256`).

```tsx
contract Negation {
    function negate8(int8 _i) public pure returns(int8) {
        return -_i;
    }

    function negate16(int16 _i) public pure returns(int16) {
        return -_i;
    }

    int8 public a = negate8(-128); // -128
    int16 public b = negate16(-128); // 128
    int16 public c = negate16(-32768); // -32768
}
```

Una forma de manejar esto es verificar el valor de una variable antes de la negaci칩n y lanzar una excepci칩n si es igual a `MIN_INT`. La opci칩n que se propone es utilizar un tipo de datos con mayor capacidad, como `int32` en lugar de `int16`, para asegurarse de que nunca se alcance el n칰mero negativo m치s peque침o (algo as칤 como hacer la negaci칩n del menor numero negativo en el rango de `int16` pero haciendo la negacion sobre un espacio en el rango de `int32`.

Un problema similar con los tipos `int` ocurre cuando `MIN_INT` se multiplica o divide por `-1`.
